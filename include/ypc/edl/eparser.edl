
enclave {
  include "sgx_eid.h"
  include "ypc/stbox/tsgx/channel/dh_cdef.h"
  from "sgx_tstdc.edl" import *;
  from "yaenclave.edl" import *;
  from "stbox.edl" import *;

  trusted {
    public uint32_t init();
    public uint32_t init_parser();
    public uint32_t parse_data_item([in, size=len]const uint8_t * sealed_data, uint32_t len);
    public uint32_t finalize();

    public uint32_t get_enclave_hash_size();
    public uint32_t get_enclave_hash([out, size=hash_size] uint8_t * hash, uint32_t hash_size);

    public uint32_t get_analyze_result_size();
    public uint32_t get_analyze_result([out, size=res_size] uint8_t * analyze_result, uint32_t res_size);

    public uint32_t init_data_source([in, size=data_size] const uint8_t * data_source_info, uint32_t data_size);

    public uint32_t init_model([in, size=data_size] const uint8_t *model, uint32_t data_size);

    public uint32_t get_parser_type();

  };


  untrusted {
    /* define OCALLs here. */
    uint32_t ocall_http_request([in, size=service_size] const char * service, uint32_t service_size,
                                [in, size=param_size] const char * param, uint32_t param_size,
                                [out, size=resp_size] char * resp, uint32_t resp_size);

    uint32_t next_data_batch([in, size=hash_size] const uint8_t * data_hash, uint32_t hash_size,
                             [out] uint8_t ** data, [out] uint32_t *len);

    void free_data_batch([user_check] uint8_t *data);

    uint32_t write_to_storage([in, size=32] const uint8_t * key,
                [in, size=len] const uint8_t * val, size_t len);
    uint32_t read_from_storage([in, size=32] const uint8_t * key,
                [out, size=data_size] uint8_t * val, size_t data_size);
  };
};
